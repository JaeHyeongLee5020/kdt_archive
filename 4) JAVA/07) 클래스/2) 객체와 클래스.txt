		# 객체(Object)와 클래스(Class)
 
-현실에서 객체는 갑자기 하늘에서 떨어지는 것이 아니라, 설계도를 바탕으로 만들어진다. 
-예를 들어 사람들이 자동차를 이용하기 위해서는 우선 공장에서 설계도를 보고 자동차를 만들어야 한다.   

-객체 지향 프로그래밍에서도 마찬가지다. 
-메모리에서 사용하고 싶은 객체가 있다면 우선 설계도로 해당 객체를 만드는 작업이 필요하다. 
-자바에서는 설계도가 바로 클래스(class) 이다.  

-클래스에는 객체를 생성하기 위한 필드와 메서드가 정의되어 있다. 
-클래스로부터 만들어진 객체를 해당 클래스의 인스턴스(instance)라고 한다.   
-자동차 객체는 자동차 클래스의 인스턴스인 셈이다. 
 그리고 클래스로부터 객제를 만드는 과정을 인스턴스화라고 한다. 

-하나의 클래스로부터 여러 개의 인스턴스를 만들 수있는데, 
 이것은 통일한 설계도로부터 여러 대의 자동차를 만드는 것과 동일하다.
                          
-객체 지향 프로그래밍 개발은 세 가지 단계가 있다.   
-첫 번째 단계는 클래스를 설계해야 한다.  
-두 번째 단계는 설계된 클래스를 가지고 사용할 객체를 생성해야 한다. 
-마지막 단계는 생성된 객체를 이용하는 것이다.  
 
-우리는 지금까지 많은 클래스를 만들어 보았다.   
-사실 클래스는 객체를 만들기 위한 설계도였지만 객체로 만들어 보지는 않았다. 
-단순히 main() 메서드만 작성해서 실행할 목적으로 클래스를 이용했다 
 하지만 main () 메서드가 없는 클래스는 객체 생성 과정을 거쳐 사용해야한다.








========================================================================================

		# 클래스선언

-사용하고자 하는 객체를 구상했다면, 그 객체의 대표 이름을 작성하게되면 이것을 클래스 이름이된다.
 예를 들어 사람 객체의 클래스는 Person으로, 자동차 객체의 클래스는 Car라는 이름으로 줄 수 있다.   
-클래스 이름은 다른 클래스와 식별할 목적으로 사용되므로 자바의 식별자 작성 규칙에 따라서 만들어야 한다.

-변수명의 작성 규칙과 동일하며 추가적으로 클래스명의 첫글자는 대문자로 시작해야 한다. (관례)

-클래스 이름은 한글이든 영어든 상관없지만, 한글로 클래스 이름을 만드는 경우는 거의 없다.  
-자바 언어는 영어 대소문자를 다른 문자로 취급하기 때문에 클래스 이름도 영어 대소문자를 구분한다. 
-관례적으로 클래스 이름이 단일 단어라면 첫 자를 대문자로 하고 나머지는 소문자로 작성한다.   
-만약 서로 다른 단어가 혼합된 이름을 시용한다면 각 단어의 첫 머리 글자는 대문자로 작성하는 것이 관례이다.
 (Ex : Calculator , Car , Member , ChatClient , ChatServer, Web_Browser)

-클래스 이름을 정했다면 "클래스이름.java"로 소스 파일을 생성해야 한다. 
-소스 파일 이름 역시 대소문지를 구분하므로 반드시 클래스 이름과 대소문자가 같도록 해야 한다.  
-소스 파일을 생성했다면 소스 파일을 열고 다음과 같이 클래스를 선언해준다.

	public class 클래스명 {

	}


-여기서 public class 키워드는 클래스를 선언할 때 사용하며 반드시 소문자로 작성해야 한다. 
-클래스 이름 뒤에는 반드시 중괄호 { }를 붙여주는데, 중괄호 시작 { 은 클래스 선언의 시작을 알려주고 
 중괄호 끝 }은 클래스 선언의 끝을 알려준다. 


	public class Car {

	}


-일반적으로 소스 파일당 하나의 클래스를 선언한다. 하지만 두 개 이상의 클래스 선언도 가능하다.

	public class Car {
	}

	class Tire {
	}

두 개 이상의 클래스가 선언된 소스 파일을 컴파일하면 바이트 코드 파일은(.class) 클래스를 선언한 개수만큼 생긴다.    
결국 소스 파일은 클래스 선언을 담고 있는 저장 단위일 뿐 클래스 자체가 아니다. 
상기 코드를 컴파일하면 Car.class와 Tire.class가 각각 생성된다. 
주의할 점은 파일 이름과 동일한 이름의 클래스 선언에만 public 접근 제한자를 붙일 수 있다. 
아직 public 접근 의미는 모른다고 하더라도 소스 파일을 생성할 때 꼭 기억해야 할 내용이다. 
만약 파일 이름과 일치하지 않는 클래스 선언에 public 접근 제한자를 붙이면 컴파일 에러가 발생한다.
가급적이면 소스 파일 하나당 동일한 이름의 클래스 하나를 선언하는 것이 좋다.



========================================================================================

		# 객체 생성과 클래스 변수

-클래스를 선언한 다음, 파일 저장을 했다면(이클립스에서는 저장) 객체를 생성할 설계도가 만들어진 셈이다. 
-클래스로부터 객체를 생성하는 방법은 다음과 같이 new 연산자를 사용하면 된다. 

	new 클래스();

-new는 클래스로부터 객체를 생성시키는 연산자이다. 
-new 연산자 뒤에는 생성자가 오는데, 생성자는 클래스() 형태를 가지고 있다.  (생성자는 뒤에서 학습한다.)
-new 연산자로 생성된 객체는 메모리 힙(heap) 영역에 생성된다. 
-현실 세계에서 물건의 위치를 모르면 물건을 사용할 수 없듯이 
  객체 지향 프로그램에서도 메모리 내에서 생성된 객체의 위치를 모르면 객체를 사용할 수 없다. 
  그래서 new 연산자는 힙 영역에 객체를 생성시킨 후， 객체의 주소를 return하도록 되어 있다.   
-이 주소를 참조 타입인 클래스 변수에 저장해 두면, 변수를 통해 객체를 사용할 수 있다.   

-다음은 클래스 타입으로 선언된 변수에 new 연산자가 return한 객체의 주소를 저장하는 코드이다.

	     # 클래스 변수 생성 후 객체 생성
	클래스 변수명;
	클래스 변수명 = new 클래스();

	     # 클래스 변수 생성과 동시에 객체 생성
	변수명 = new 클래스();


이렇게 new 연산자로 객체를 생성하고 return된 객체의 주소를 변수에 저장하면 변수가 객체를 참조하게 된다.
                               







클래스 선언에서부터 생성까지 예제를 통해 익혀보자. 
다음 예제는 Student 클래스를 선언하고 StudentExample 클래스의 main() 메서드에서 Student 객체를 생성한다.

// Student 클래스 생성
public class Student {

}



// main() 메서드가 있는 StudentMain클래스에서 Student 클래스의 객체 생성
public class StudentMain {
	public static void main(String[] args) {
		Student std1 = new Student();	// std1 객체 생성
		System.out.println("st1 변수가 Student 객체를 참조합니다.");
		
		Student std2 = new Student();	// std2 객체 생성
		System.out.println("st2 변수가 또 다른 Student 객체를 참조합니다.");
	}
}


예제가 실행되면 다음 메모리에 클래스 변수와 객체가 생성된다. 
Student 클래스는 하나지만 new 연산자를 사용한 만큼 객체가 메모리에 생성된다. 
이러한 객체들은 Student 클래스의 인스턴스들이다. 
비록 같은 클래스로부터 생성되었지만 각각의 Student 객체는 자신만의 
고유 데이터를 가지면서 메모리에서 활동하게 된다.
std1과 std2가 참조하는 Student 객체는 완전히 독립된 서로 다른 객체이다.
                             


여기서 우리는 Student와 StudentExample 클래스의 용도에 대해 알이볼 필요가 있다. 

-클래스는 두 가지 용도가 있다. 
-하나는 라이브러리(API: Application Program Interface)용이고 다른 하나는 실행용이다. 
 1) 라이브러리 클래스 : 라이브러리 클래스는 다른 클래스에서 이용할 목적으로 설계된다. 
    프로그램 전체에서 사용되는 클래스가 100개라면 99개는 라이브러리이고 단 하나가 실행 클래스이다. 
 2) 실행 클래스 : 실행 클래스는 프로그램의 실행 진입점인 main() 메서드를 제공하는 역할을 한다.
 
-Student는 라이브러리 클래스이고 StudentExample은 실행 클래스이다. 
-라이브러리 클래스는 반드시 객체를 생성하고 사용해야 한다.
 (단 정적 멤버와 정적 메소드는 객체 생성없이 사용이 가능하다.)

Student에 main() 메서드를 작성해서 라이브러리인 동시에 실행 클래스로 만들 수도 있다.

	public class Student {				// Student 클래스 내에서
		public static void main(String[] args) {		// main메서드 생성
			Student std1 = new Student();		// std1 객체 생성
			System.out.println("st1 변수가 Student 객체를 참조합니다.");
			
			Student std2 = new Student();		// std2 객체 생성
			System.out.println("st2 변수가 또 다른 Student 객체를 참조합니다.");
		}
	}

프로그램이 단 하나의 클래스로 구성된다면 위와 같이 작성하는 것이 좋은 방법일 수 있지만, 
대부분의 객체 지향 프로그램은 라이브러리 (부품 객체 및 완성 객체)와 실행 클래스가 분리되어 있다.







========================================================================================

		# 객체와 클래스

현실에서 객체는 갑자기 하늘에서 떨어지는 것이 아니라, 설계도를 바탕으로 만들어진다. 
예를 들어 사람들이 자동차를 이용하기 위해서는 우선 공장에서 설계도를 보고 자동차를 만들어야 한다.   

객체 지향 프로그래밍에서도 마찬가지다. 
메모리에서 사용하고 싶은 객체가 있다면 우선 설계도로 해당 객체를 만드는 작업이 필요하다. 
자바에서는 설계도가 바로 클래스(class) 이다.  

클래스에는 객체를 생성하기 위한 필드와 메서드가 정의되어 있다. 
클래스로부터 만들어진 객체를 해당 클래스의 인스턴스(instance)라고 한다.   
자동차 객체는 자동차 클래스의 인스턴스인 셈이다. 
그리고 클래스로부터 객제를 만드는 과정을 인스턴스화라고 한다. 

하나의 클래스로부터 여러 개의 인스턴스를 만들 수있는데, 
이것은 통일한 설계도로부터 여러 대의 자동차를 만드는 것과 동일하다.
                          
객체 지향 프로그래밍 개발은 세 가지 단계가 있다.   
첫 번째 단계는 클래스를 설계해야 한다.  
두 번째 단계는 설계된 클래스를 가지고 사용할 객체를 생성해야 한다. 
그리고 마지막 단계는 생성된 객체를 이용하는 것이다.  
 
우리는 지금까지 많은 클래스를 만들어 보았다.   
사실 클래스는 객체를 만들기 위한 설계도였지만 객체로 만들어 보지는 않았다. 
단순히 main() 메서드만 작성해서 실행할 목적으로 클래스를 이용했다 
하지만 main () 메서드가 없는 클래스는 객체 생성 과정을 거쳐 사용해야한다.




















========================================================================================

		# 객체 생성과 클래스 변수

클래스를 선언한 다음， 컴파일을 했다면(이클립스에서는 저장) 객체를 생성할 설계도가 만들어진 셈이다. 
클래스로부터 객체를 생성하는 방법은 다음과 같이 new 연산자를 사용하면 된다.

	new 클래스();

-new는 클래스로부터 객체를 생성시키는 연산자이다. 
-new 연산자 뒤에는 생성자가 오는데, 생성자는 클래스() 형태를 가지고 있다. 
-new 연산자로 생성된 객체는 메모리 힙(heap) 영역에 생성된다. 
-현실 세계에서 물건의 위치를 모르면 물건을 사용할 수 없듯이 
  객체 지향 프로그램에서도 메모리 내에서 생성된 객체의 위치를 모르면 객체를 사용할 수 없다. 
  그래서 new 연산자는 힙 영역에 객체를 생성시킨 후， 객체의 주소를 return하도록 되어 있다.   
-이 주소를 참조 타입인 클래스 변수에 저장해 두면, 변수를 통해 객체를 사용할 수 있다.   

-다음은 클래스 타입으로 선언된 변수에 new 연산자가 return한 객체의 주소를 저장하는 코드이다.

	클래스 변수명;
	변수명 = new 클래스();
	클래스 변수명 = new 클래스();


이렇게 new 연산자로 객체를 생성하고 return된 객체의 주소를 변수에 저장하면 변수가 객체를 참조하게 된다.
                               


클래스 선언에서부터 생성까지 예제를 통해 익혀보자. 
다음 예제는 Student 클래스를 선언하고 StudentExample 클래스의 main() 메서드에서 Student 객체를 생성한다.

public class Student {

}


public class StudentMain {
	public static void main(String[] args) {
		Student std1 = new Student();	// std1 객체 생성
		System.out.println("st1 변수가 Student 객체를 참조합니다.");
		
		Student std2 = new Student();	// std2 객체 생성
		System.out.println("st2 변수가 또 다른 Student 객체를 참조합니다.");
	}
}


예제가 실행되면 다음 그림과 같이 메모리에 클래스 변수와 객체가 생성된다. 
Student 클래스는 하나지만 new 연산자를 사용한 만큼 객체가 메모리에 생성된다. 
이러한 객체들은 Student 클래스의 인스턴스들이다. 
비록 같은 클래스로부터 생성되었지만 각각의 Student 객체는 자신만의 
고유 데이터를 가지면서 메모리에서 활동하게 된다.
std1과 std2가 참조하는 Student 객체는 완전히 독립된 서로 다른 객체이다.
                             

-여기서 우리는 Student와 StudentExample 클래스의 용도에 대해 알아볼 필요가 있다. 
-클래스는 두 가지 용도가 있다. 
-하나는 라이브러리(API: Application Program Interface)용이고 다른 하나는 실행용이다. 
-라이브러리 클래스는 다른 클래스에서 이용할 목적으로 설계된다. 
-프로그램 전체에서 사용되는 클래스가 100개라면 99개는 라이브러리이고 단 하나가 실행 클래스이다. 
-실행 클래스는 프로그램의 실행 진입점인 main() 메서드를 제공하는 역할을 한다. 
-Student는 라이브러리 클래스이고 StudentExample은 실행 클래스이다. 

Student에 main() 메서드를 작성해서 라이브러리인 동시에 실행 클래스로 만들 수도 있다.

public class Student {
	public static void main(String[] args) {	// main메서드
		Student std1 = new Student();	// std1 객체 생성
		System.out.println("st1 변수가 Student 객체를 참조합니다.");
		
		Student std2 = new Student();	// std2 객체 생성
		System.out.println("st2 변수가 또 다른 Student 객체를 참조합니다.");
	}
}

프로그램이 단 하나의 클래스로 구성된다면 위와 같이 작성하는 것이 좋은 방법일 수 있지만, 
대부분의 객체 지향 프로그램은 라이브러리 (부품 객체 및 완성 객체)와 실행 클래스가 분리되어 있다.






========================================================================================

		# 클래스의 구성 멤버

클래스에는 객체가 가져야할 구성 멤버가 선언된다. 
구성 멤버에는 필드(Field), 생성자(Constructor ), 메서드(Method)가 있다. 
이 구성 멤버들은 생략되거나 복수개가 작성될 수 있다.

public class ClassName {
	
	int fieldName;		// 필드 또는 멤버 변수
	
	ClassName(){		// 생성자
	}
	
	void methodName(){	// 메서드
	}

}



	# 필드(field)
-필드는 객체의 고유 데이터, 부품 객체 상태 정보를 저장하는 곳이다.  
-선언 형태는 변수(variable)와 비슷하지만, 필드를 변수라고 부르지 않는다. 
-변수는 생성자와 메서드 내에서만 사용되고 생성자와 메서드가 실행 종료되면 자동 소멸된다.   
 하지만 필드는 생성자와 메서드 전체에서 사용되며 객체가 소멸되지 않는 한 객체와 함께 존재한다.

	# 생성자(Constructor)
-생성자는 new 연산자로 호출되는 특별한 중괄호 { }블록이다. 
-생성자의 역할은 객체 생성시 초기화를 담당한다. 
-필드를 초기화하거나, 메서드를 호출해서 객체를 사용할 준비를 한다. 
-생성자는 메서드와 비슷하게 생겼지만, 클래스 이름으로 되어 있고 retrun 타입이 없다.

	# 메서드(Method)
-메서드는 객체의 동작에 해당하는 중괄호 { }블록을 말한다. 
-중괄호 블록은 이름을 가지고 있는데, 이것이 메서드 이름이다.  
-메서드를 호출하게 되면 중괄호 블록에 있는 모든 코드들이 일괄적으로 실행된다.   
-메서드는 필드를 읽고 수정하는 역할도 하지만 다른 객체를 생성해서 다양한 기능을 수행하기도 한다. 
-메서드는 객체간의 데이터 전달의 수단으로 사용된다. 
-외부로부터 매개값을 받을 수도 있고, 실행 후 어떤 값을 return할 수도 있다.



========================================================================================

		## 필드(Field)

필드(Field)는 객체의 고유 데이터 객제가 가져야 할 부품 객체의 현재 상태 데이터를 저장하는 곳이다. 
자동차 객체를 예로 들어 보면 제작회사, 모델, 색깔, 최고 속도는 고유 데이터에 해당하고, 
현재 속도, 엔진 회전수는 상태 데이터에 해당한다. 
그리고 차제, 엔진, 타이어는 부품에 해당한다.
따라서 자동차 클래스를 설계할 때 이 정보들은 필드로 선언되어야 한다.
                       

	# 필드(멤버 변수) 선언
-필드 선언은 클래스 중괄호 { } 블록 어디서든 존재할 수 있다. 
-생성자 선언과 메소드 선언의 앞과 뒤 어떤 곳에서도 필드 선언이 가능하다. 
 하지만 생성자와 메소드 중괄호 블록 내부에는 선언될 수 없다. 
-생성자와 메소드 중괄호 블록 내부에 선언된 것은 모두 지역 변수가 된다. 
-필드 선언은 변수의 선언 형태와 비슷하기 때문에 클래스 멤버 변수라고 부르기도 한다.

타입 필드명 = 초기값;


타입은 필드에 저장할 데이터의 종류를 결정한다. 
타입에는 기본 타입 (byte, short, int, long, f1oat, double, boolean )과 
참조 타입 (배열, 클래스, 인터페이스)이 모두 올 수 있다. 
필드의 초기값은 필드선언 시 주어질 수도 있고 생략될 수도 있다. 

다음은 올바르게 필드를 선언한 예를 보여준다.

String company = "현대자동차"; 
String model = "쏘나타"; 
int maxSpeed = 200;
int productionYear;
boolean engineStart;

초기값이 지정되지 않은 필드들은 객체 생성 시 자동으로 기본 초기값으로 설정된다. 
필드의 타입에 따라초기값이 다른데, 다음표는 필드 타입별 기본 초기값을 보여준다.


=========================================================================================
|	분류			|	 데이터 타입		|	 초기값		|
=======================================================================
|		|		|  byte				|   0			|
|		|		--------------------------------------------------------
|		|		|  char				|   /u0000(빈공백)	|
|		|		--------------------------------------------------------
|  기본 타입	|   정수 타입	|  short				|  0			|
|		|		--------------------------------------------------------
|		|		|  int				|  0			|
|		|		--------------------------------------------------------
|		|		|  long				|  0L			|
========================================================================================
|		|		|  float				|  0.0F			|
|		|   실수 타입	--------------------------------------------------------
|		|		|  double				|  0.0			|
========================================================================================
|		|   논리 타입	|  boolean			|  false			|
========================================================================================
|				|  배열				|  null			|
|				--------------------------------------------------------
|          	     참조 타입		|  클래스(String 포함)		|  null			|
|				--------------------------------------------------------
|				|  인터페이스			|  null			|
=========================================================================================

정수 타입 필드는 0, 실수 타입 필드는 0.0 그리고 boolean 필드는 false로 초기화되는 것을 볼수 있다. 
참조 타입은 객체를 참조하고 있지 않은 상태인 null로 초기화된다.








========================================================================================

		# 필드 사용

필드를 사용한다는 것은 필드값을 읽고 변경하는 작업을 말한다. 
클래스 내부의 생성자나 메소드에서 사용할 경우 단순히 필드 이름으로 읽고 변경하면 되지만,
클래스 외부에서 사용할 경우 우선적으로 클래스로부터 객체를 생성한 뒤 필드를 사용해야 한다. 
그 이유는 필드는 객체에 소속된 데이터이므로 객체가 존재하지 않으면 필드도 존재하지 않기 때문이다.

                      

public class Car {		// Car 클래스 생성
	int speed;		// 필드 또는 멤버 변수 (내부 클래스에서는 바로 변경이 가능하다.)

	Car(){			// 생성자
		speed = 0;	// 값 변경 (내부 클래스에서는 바로 변경이 가능하다.)
	}
	
	void method() {		// 메서드
		speed = 10;	// 값 변경 (내부 클래스에서는 바로 변경이 가능하다.)
	}

}

public class Person {			// Person 클래스 생성
	void  method()  {			// 메서드 생성
		Car myCar  = new Car(); 	// 메서드 안에서 Car 객체 생성
		myCar.speed  = 68;		// 객체를 사용하여 Car 클래스의 필드값 변경
}

위 코드를 보면 Car 클래스의 speed 필드는 생성자와 메소드에서 변경이 가능하다. 
사용 방법은 변수와 동일한데, 차이점은 변수는 자신이 선언된 생성자 또는 메소드 블록 내부에서만 사용할 수있는 반면 
필드는 생성자와 모든 메소드에서 사용이 가능하다. 
외부 Person클래스에서 Car클래스의 speed 필드값을 사용하려면 Car객체를 우선 생성해야 한다.


	Car myCar = new Car();

myCar 변수가 Car 객체를 참조하게 되면 도트(.) 연산자를 사용해서 speed 펼드에 접근할 수 있다. 
도트(.) 연산자는 객체 접근 연산자로 객체가 가지고 있는 필드나 메소드를 사용하고자 할 때 사용된다. 
다음 코드는 Car 객체의 speed 필드값을 60으로 변경하고 있다.


	myCar.speed = 60;




	# Car 클래스 필드 선언 및 외부 클래스에서 필드값 읽기 및 변경

public class Car {		// Car 클래스 생성
	String company = "현대자동차";	// 필드 생성 (멤버 변수)
	String model ="쏘나나";	// 필드 생성필드 생성
	String color = "검정";	// 필드 생성필드 생성
	int maxSpeed = 200;	// 필드 생성필드 생성
	int speed;			// 필드 생성필드 생성
}


public class CarExample {	// CarExample 클래스 생성
	public static void main(String[] args) {
		
		Car myCar = new Car();	// Car클래스의 객체 생성
		Car myCar2 = new Car();	// Car클래스의 객체 생성
		
		System.out.println(myCar);	// 서로 다른 객체이다.
		System.out.println(myCar2);	// 서로 다른 객체이다.
	}
}








public class CarExample {
	public static void main(String[] args) {

		Car myCar = new Car();
		
		System.out.println("생산 회사 : " + myCar.company);
		System.out.println("모델명 : " + myCar.model);
		System.out.println("생상 : " + myCar.color);
		System.out.println("최고 속도 : " + myCar.maxSpeed);
		System.out.println("현재 속도 : " + myCar.speed);
	}
}

Car 클래스는 speed 필드 선언시 초기값을 주지 않았다. 
그러나 출력해보면 기본값인 0이 들어있는 것을 볼수 있다. 

































