 			## 작업 스레드 생성과 실행 

-멀티 스레드로 실행하는 애플리케이션을 개발하려면 먼저 몇 개의 작업을 병렬로 실행할지 결정하고  각 작업별로 레드를 생성해야 한다.  	

-어떤 자바 애플리케이션이건 메인 스레드는 반드시 존재하기 때문에 메인 작업 이외에 
 추가적인 병렬 작업의 수만큼 스레드를 생성하면 된다. 
-자바에서는 작업 스레드도 객체로 생성되기 때문에 클래스가 필요하다. 
-java.1ang.Thread 클래스를 직접 객체화해서 생성해도 되지만, 
 Thread를 상속해서 하위 클래스를 만들어 생성할 수도 있다.




===================================================================================================

		# Runnable 인터페이스를 구현

-java.1ang.Thread 클래스로부터 작업 스레드 객체를 직접 생성하려면 다음과 같이 Runnable을 매개값으로 갖는 생성지를 호출해야 한다.

	Thread thread new Thread(Runnable target);


-Runnable은 작업 스레드가 실행할 수 있는 코드를 가지고 있는 객체라고 해서 붙여진 이름이다. 
-Runnable은 인터페이스 타입이기 때문에 구현 객체를 만들어 대입해야 한다. 
-Runnable에는 run() 메소드 하나가 정의되어 있는데, 
 구현 클래스는 run() 메소드를 재정의해서 작업 스레드가 실행할 코드를 작성해야 한다. 

다음은 Runnable 구현 래스를 작성하는 방법을 보여준다. 

	public class Task implements Runnable { 
		@Override
		public void run() { 
			스레드가 실행할 코드;
		}
	}


-Runnable은 작업 내용을 가지고 있는 객체이지 실제 쓰레드는 아니다. 
-Runnable 구현 객체를 생성한 후, 것을 매개값으로 해서 Thread 생성자를 호출하면 비로소 작업 쓰레드가 생성된다.

	Runnable task = new Task(); 
	Thread thread = new Thread(task);



-코드를 좀 더 절약하기 위해 Thread 생성자를 호출할 때 Runnable 익명 객체를 매개값으로 사용할 수 있다. 
 (이 방법 이 더 이 사용)

	Thread thread = new Thread(new Runnable() { 	// 익명구현객체
		public void run () {
			// 스레드가 실행할 코드;
		}
	}); 



-작업 쓰레드는 생성되는 즉시 실행되는 것이 아니라 start() 메소드를 호출해야만 실행된다. 

	thread.start(); 

-start() 메소드가 호출되면, 작업 쓰레드는 매개값으로 받은 Runnable의 run() 메소드를 실행하면서 
 자신의 작업을 처리한다.



package test.chapter12.example01;
public class Test {
	public static void main(String[] args) {
		// 자바는 기본적으로 싱글 쓰레드를 지원한다.
		
		System.out.println("프로그램 시작");
		
		// 인터페이스는 객체를 생성할 수 없다.
//		Runnable runnable = new Runnable();
		Runnable runnable = new ThreadImpl();
		
		// 쓰레드 객체 생성 (매개변수로 Runnable 객체 대입)
		Thread thread = new Thread(runnable);
		
		thread.start();
		
		// 메인 쓰레드
		for(int i = 0; i < 1000; i++) {
			System.out.print("# ");
		}
		System.out.println();
		
		System.out.println("프로그램 종료");
	}
}



public class ThreadImpl implements Runnable {

	@Override
	public void run() {
		for(int i = 0; i < 1000; i++) {
			System.out.print("* ");
		}
	}
}


프로그램 시작
# # # # # # # # # # # # # # # # # * * * * * * * * * * # # # # # # # * # # # # # # # # # # * * * * * * * * * * * # # * * * * * * * * * # # # # # # # # # # # * * * * * * * * * # # # # # # # # # * * * * # # # # # # # # * * * * * * * * * # # # # # # # # # # # # # * * * * * * * * # # # # # # # # # * * * * * * * * * # # # # # # # # # # # # # # # * * * * * * * * * # # # # # # # # # * * * * * * * * * * # # # # * * * * * * * * # # # # # # # # # # # # # # # # * * * * * * * * * # # # # # # # # # # # # # # # # # # * * * * * * * # # # # # # * * * * * * * * # # # # # # # # # # # # # # # * * * * * * * * # # # # # # # # * * * * * * * # # # # # # # # # # # # * * * * * * * # # # # # # # # # # * * * * * * # # # # # # # # # # # # * * * * * * * * # # # # # # # # # * * * * * * * # # # # # # # # # * * * * * * * * * # # # # # # # # # * * * * * * * * * # # # # # # # # # * * * * * * * * * # # # # # # # # # * * * * * * * * * * # # # # # # # # # * * * * * * * * * # # # # # # # # * * * * * * * * * # # # # # # # # # * * * * * * * * # # # # # # # # * * * * * * * * # # # # # # # # * * * * * * * # # # # # # * * * * * * * # # # # # # # # # * * * * # # # # # # * * * * * * * * * # # # # # # # # * * * * * * * * # # # # # # # # # * * * * * * * * # # # # # # # # # * * * * * * * * * # # # # # # # # * * * * * * * * * # # # # # # * * * * * * * * # # # # # # # * * * * * * # # # # # # # # # * * * * * * * * * * * * * # # # # # # # # # # # # # # # # # # # # * * * * * * * * # # # # # # # # # # # # * * * * * * * * # # # # # # # # * * * * * * * * * * # # # # * * * * * * * # * * * * # # # # # # * * * * # # # # # # # # # * * * * * # # # # # # * * * * * * # # # # # * * * * * * * # # # # # # # * * * * * * # # # # # # * * * * * * * * * * * * * * # # # # # * * * * * * * # # # # # # # # # # * * * * * # # # # # # # # * * * * * * * * * * * * * # # # # # # # # # # * * * * * * * # # # # # # # * * * * * * * * # # # # # # # # # * * * * * * * * * * * # # # # # # * * * * * * * * * * * # # # # # # # # # * * * * # # # # # * * * * * * * # # # # # # # * * * * * * * * * * * * # # # # # # * * * * * # # # # # # * * * * # # # # # * * # # # # # # # * * * * * * * * * * # # # # # # # * * * * * * * * * # # # # # # # * * * * * * # # # # # # * * * * * * * * * # # # # # # # * * * * * * * * # # # # # # # # * * * * * * * * # # * * * * * * * * * * * # # * * # # # * * * * * * * * * * * # # * * * * * * * * * # # # # * * * * * # # # # # # # * * * * * * * * * # # # # # * * * * # # # # * * * * # # # * * * * * * # # # # # # # # # * * * * * * * * * # # # # # # # # # * * * * # # # # # # # # # # # # * * # # # # # # # # # * * * * # # # # # # # # # # # # # # * * * * # # # # # # # # # # # # # # * * * * * * # # # # # # # * * * * * * * * # # # # # # * * * * # # # # # # * * * * # # # # # # * * * * * * * * * * * * * * * * # # * * * * * * * * * * # # # # # # # # # # # # * * * * * * * * * * * # # # # # # # # * * * * * * * * # # # # # # * * * * * * * * * * * * # # # # # # # # * * * * * * * * * * * * # # # # # # # # # # # # # # # # # * * * * * * * * * # # # # # # # # # # # # # # # # # # # # # # # # # # * * * * * * * * * # # # # # # * * * * * * * # # # * * * * * # * * * * * * # # # * * * * # # # # # * * * * # # # # # # * * * * * * * * * * * # # # # # * * * * * * * # # # # # # * * * * * * * * * * # # # # # * * * * * * # # # # # # # # # # * * * * * * * * * * * # # # # # # # # # # # # # # * * * * # # # # # # # * * * * * * * * * # * * # # # # # # * * * * * * * * * * * # # # # # # # # # * * * * # # # # # # # # # * * * * * * * * * * * * # # # # # # # # * * * * * * * # # # # # # # # # # # # # # # # # # * * * * * * * # # # # * * * * * * * * * # * * * * * * * * * # # # # # # # # # # * * * * * * * * * * # # * * * * * # # # # # # # # # * * * * * * * # # # # # * * * * * * * # # # # # # # # * * * * * * * # # # * * * * * * * * * * * * * * * # # # # # # # # # * * * * * * * * * * # # # * * * * * * * * * # * * * * * * * * * # # # * * * * * * * * * * * * * * * * # # # # # # * * # # # # * * # # * * * * # # # * * # # # * * # # * * * * # # # * * * 
프로그램 종료






===================================================================================================

		# Thread 하위 클래스로부터 생성 

-작업 스레드가 실행할 작업을 Runnable로 만들지 않고, 
 Thread의 하위 클래스로 작업 스레드를 정의하면서 작업 내용을 포함시킬 수도 있다. 

-다음은 작업 드 클래스를 정의하는 방법인데, Thread 클래스를 상속한 후 
  run() 메소드를 재정의(overriding) 해서 쓰레드가 실행할 코드를 작성하면 된다. 

-작업 스레드 클래스로부터 작업 스레드 객체를 생성하는 방법은 일반적인 객체를 생성하는 방법과 동일하다.

	public class MyThread extends Thread {
		@Override	// Thread 클래스의 run() 메소드를 재정의해야 한다.
		poublic void run(){
			// 작업 내용
		}
	}


이렇게 생성된 작업 스레드 객체에서 start () 메소드를 호출하면 작업 스레드는 자신의 run() 메소드를 실행하게 된다.

	Thread thread = new MyThread();
	thread.start();




package test.chapter12.example01;
public class MyThreadMain {
	public static void main(String[] args) {	
		// 메인 쓰레드가 처리
		System.out.println("프로그램 시작");
		
		// Thread 상속을 사용하여 쓰레드 객체 생성
		Thread myThread = new MyThread();
		
		// Runnable 인터페이스를 구현하여 쓰레드 객체 생성
		Runnable runnable = new YourThreadImpl();
		Thread yourThread = new Thread(runnable);
		
		// 작업 쓰레드가 처리
		myThread.start();
		yourThread.start();
		
		// 메인 쓰레드가 처리
		for(int i = 0; i < 1000; i++) {
			System.out.print("#");
		}
		
		// 메인 쓰레드가 처리
		System.out.println();
		
		// 메인 쓰레드가 처리
		System.out.println("프로그램 종료");
	}
}




// Thread 클래스를 상속
public class MyThread extends Thread {
	
	@Override
	public void run() {
		for(int i = 0; i < 1000; i++) {
			System.out.print("*");
		}
	}
}




public class YourThreadImpl implements Runnable {

	@Override
	public void run() {
		for(int i = 0; i < 1000; i++) {
			System.out.print("|");
		}
	}
}


프로그램 시작
############*********|||||||||||####***********|#####***||||||||||############**********|||||||||########*********|||||||||||#########*******||||||###########*************|||||||||############*******|||||||||##########*********|||||||||########********|#########*********||||||||||#######********||||||||#######*******|||||||||||########******|||||||########*********|||||||||||||||||#########**||#########*********||||#########*********||||||||#######******||||||||########*****|||||||||#########*********||||||||#########********||||||||########*********||||||||#######********||||||||||########********||||||############********||||||#######****||||||#########*******||||||||########*********||||||||||#######*******|||||||########*************||||||########*******|||||#####****|||||########***********||||########**||||||######********||||||||######**||||######*********||#######****||||||||##########******||||||####***||||########****||||###############************|||||||##**||||||##******||||######****|||||||||||||||#########****||||||||||||||##########******||||||#######*******||||||######******|||||||######*******|||||#######******|||||||#######*******||||||######*****|||||||#####******||||######****|||||####**|||####################************||||||||##########********|||||||||#####************||||||############************||||||||############****|||||####******|||||####****||####****||||||||####****||||########**||||######****|||||####**|||||####******|||||||||||########################**********||||||||||||####*******|||||||#######*********|||||||||||||||||||||||#######**********|||||||||||||###########************|||||||||||||||||########**********|||||||||||||##########***********|||||||||||||################*************|||||||||||||||||#################**********||||||||||||########*****||||||######*******|||#######******************|||||||############*********|||||||||||||||#########**********|||#########***|||||||||||||||######**********||||||||||##########################*************|********#######|||||***#######################|###############***********|||||||||||############*********||||||||||||#############***********||||||||||######*******|||||||########**********||||||||||||||||#############*********************|||||||||###***********|||||||||||||||#########*********|||||||||||||||||||||||||##############***********|||||||||||||||||###############***************||||||||||############*****************||||||||||#########*********||||||||||############**********|||||||###########***||||||||||###############*****************||||||||||||#######************|||||||||############*************|||||||||||#######**********|||||||||||||##########***********|||||||||||||||||||||||||##########***||||||||||#############*****************||||||||#################******||||||||||||||||#####
**********||||||||||||||프로그램 종료
******|||||||***||||||||||||||||||*********||||||||||||||*********************************************************************************





		## 익명 구현 객체를 사용하여 작업 쓰레드 생성



package test.chapter12.example01;
public class ThreadExample {
	public static void main(String[] args) {
		System.out.println("프로그램 시작");	// 메인 쓰레드
		
		// 인터페이스는 객체를 직접 생성할 수 없다.
		Runnable runnable1 = new Runnable() {
			@Override
			public void run() {
				for(int i = 0; i < 1000; i++) {
					System.out.print("*");
				}
			}
		};
		
		Runnable runnable2 = new Runnable() {
			@Override
			public void run() {
				for(int i = 0; i < 1000; i++) {
					System.out.print("#");
				}
			}
		};
		Thread threadA = new Thread(runnable1);
		Thread threadB = new Thread(runnable2);
		threadA.start();	// 작업쓰레드
		threadB.start();	// 작업쓰레드
		
		for(int i = 0; i < 1000; i++) {		// 메인 쓰레드
			System.out.print("|");
		}
		
		System.out.println("프로그램 조료");	// 메인 쓰레드
	}
}



프로그램 시작
|||********##########|||||||||************##########||||*********###|||||||||||*********##########||||||||||||***********##########||||||||*******#######|||||||||***********#########||||||||||**********########||||||*********#######|||||||||********####|||||||||*********#########||*********#########||||||||*********#########||||||||*********#######|||||||||*********####|||||||********##########|||||||********#########|||||||||********#######|||||||||||||||******##########|||||||||********##########||||||||||||||||********########||||||||********########||||||||********########||||||||********########||||||||**********##############|||||||*****#######||||*******#######|||||||*********#######|||||********########||||||**********#####|||||*********####||||||********#######||||||||***************######|||||||*****####||||||*****######|||||||*******#####|||||||||||******#######|||||||******####|||||||********######||||||||||||*********##|||||||*****************#####||*******########||||||||||*****####|||||||*******####||||*******##||||****#######||||||||********#######|||||||||********######||||||******######||||||******#####||||||******#####|||||||*******######|||||||******#######|||||******######|||||*****########|||********######|||||****####||||*****#######||||||*****######|||||******####||||||*****#####|||||||||||****######||||||*******###########||||||||*************###########||||||||||||||||||*******************##########################|||||||||||||************#########||||||||||||************########|||||||||||||||||********#############||||||||||******########||||||||||******###########||||||||||||********#######||||||||||||||||**********************##################|||||||||||||||**********##############||||||||||**********################||||||||||****************###############|||||||||||||*******#######||||||||*******#############|||||||||||||***************#########||||||||||*******############|||||||||||**************####||||||||||****************##########||||||||||||||||||||||||*********###########||||||||*****************##################||||||||**************###########||||||||||||||||||***********##################|||||||||||||||******####|||||||||||||||||****************############|||||||||*************######||||||||*|||||||########*********************|||||||||||||||||#########******************||||||||||||||##############******||||||||||##########********************||||||||||#######***************||||||||||||###############****|||||||||||########**************||||||||||||||############***********||||#################****************||||||||||||##########*************||||||||||##########**********||||||||##########*******|||||######***|||||||||||||||||||#################****************|||||||||||||###############################******************************||||||##########****||||||||||||||||###########******||||||||||#######******|||||#######|||||||#####|||||||||||프로그램 조료
#########################################################








===================================================================================================


	# Main 쓰레드

-main 메서드의 코드를 수행하는 쓰레드
-쓰레드는 사용자 쓰레드와 데몬 쓰레드 두 종류가 있다.  (보조 쓰레드)
-실행중인 사용자 쓰레드가 하나도 없을 때 프로그램은 종료된다.


package test.chapter12.example01;
public class ThreadMain {
	
	static long startTime = 0;
	
	public static void main(String[] args) {
		
		System.out.println("프로그램 시작");
		
		Thread threadA = new ThreadA();
		Thread threadB = new ThreadB();
		
		threadA.start();
		threadB.start();
		
		startTime = System.currentTimeMillis();
		
		try {
			threadA.join();	// 해당 쓰레드의 작업이 모두 끝날때까지 main 쓰레드는 대기
			threadB.join();	// 해당 쓰레드의 작업이 모두 끝날때까지 main 쓰레드는 대기
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		
		double endTime = (System.currentTimeMillis() - startTime) / 1000.0;
		System.out.println("\n소요 시간 : " + endTime);
		System.out.println("프로그램 종료");
	}
}




package test.chapter12.example01;
public class ThreadA extends Thread {
	
	@Override
	public void run() {
		for(int i = 0; i < 1000; i++) {
			System.out.print("*");
		}
	}
}


package test.chapter12.example01;
public class ThreadB extends Thread {

	@Override
	public void run() {
		for(int i = 0; i < 1000; i++) {
			System.out.print("#");
		}
	}
}



프로그램 시작
**************##############*********###########**********#########****##########**********############*********##########*******#########***#########*************###******#########**********#######*******############*********#########************#########******#########********########********########*******###############**********#########*******#########*********#########*********#########*********#########*********########****#######*********########**********#######***************########**#########*******#########*********########*******#########***********#######********########****############*********########********########********########********#########********#########*******##########********#########*******#########******#########********#######*#######*********#################*********########*********#######********#############********##################*********#####**##############****#######*********#######********########**********#######******######**#####*********####**#####*********#*#**********#######*******######*******#######*******#######******######******######******######********######*******###########################*********************###########*******#######*******#######*******#######********#######******######*****#######******######******######**##******##############***********########*************######************########################**************###########*********##*****########****####****####****####****####****####******#######****####*****###########**#########**********####################********################***************************##################**********##############******************##################*************########################*****************##########*****************#####################*************######**********####***********#########*********########*******#*********###########********########************************************************************************************
소요 시간 : 0.033
프로그램 종료






===================================================================================================

	# I/O Blocking

두 쓰레드가 서로 다른 자원을 사용하는 작업의 경우 싱글 쓰레드 프로세스보다 멀티 쓰레드 프로세스가 더 효율적이다. 
예를 들면 사용자로부터 데이터를 입력받는 작업, 네트워크로 파일을 주고받는 작업, 
프린터로 파일을 출력하는 작업과 같이 외부기기와 입출력을 필요로 하는 경우가 이에 해당한다.

만일 사용자로부터 입력받는 작업(A)과 화면에 출력하는 작업(B)을 하나의 쓰레드로 처리한다고 하면 
사용자가 입력을 마칠 때까지 아무 일도 하지 못하고 기다리기만 해야한다. 
그러나 두개의 쓰레드로 처리한다면 사용자의 입력을 기다리는 동안 다른 쓰레드가 작업을 처리할 수 있기 때문에 
보다 효율적인 CPU의 사용이 가능하다.

쓰레드가 입/출력(I/O)처리를 위해 기다리는 것을 I/O bocking이라고 한다.






































